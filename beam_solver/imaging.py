from beam_solver import casa_utils as ct
from beam_solver import fits_utils as ft
from astropy.io import fits
from astropy import wcs
import numpy as np
import pylab
import os

class Imaging(object):
    def __init__(self, ms):
        """
        Object to store measurement sets of meausrement files containing visibilities and performs
        operations such as imaging.
        Parameters
        ----------
        ms : str
            Input Measurement set file containing visibilities are required metadata.        
        imagename : str
            Name of output casa image.
        """
        self.ms = ms

    def flag_antenna(self, antenna, script='flag_a', del_script=True):
        """
        Flags antennas
        """
        ct.flag_antenna(self.ms, antenna)

    def generate_image(self, imagename, antenna='', cellsize='8arcmin', npix=512, niter=0, threshold='0Jy', weighting='uniform', start=200, stop=900, uvlength=0, gridmode='widefield', wprojplanes=-1, script='clean', del_script=True):
        """
        Generates multi-frequency synthesized images using all baselines within the specified cutoff threshold

        Parameters
        ---------
        antenna: string
            Antenna(s) or baseline(s) to used for imaging.
            e.g antenna='0' uses data from antenna 0 only
            antenna='0,4,5' uses data from antennas 0,4 and 5
            antenna='0&3' uses data from baseline 0-3
            antenna='0&3; 4&3' uses data from baselines 0-3 and 4-3
            Default is ''(all) which uses all the baselines
        imagename : str
            Name of output casa image.
        cellsize: string
            Degrees to be contained in one pixel of the image.
            Default is 8 arcmins.
        npix: int
            Number of pixel the output image is along x(l) and y(m) axis.
            Default is 512.
        niter: integer
            Number of iterations to use for deconvolution. Default is 0.
            Hence, dirty images are generated by default.
        threshold: string
            Cleaning threshold in Jy or mJy. Default is 0 Jy.
        weighting: string
            Weighting to be using for gridding of uv points. Default is uniform.
        start: int
            Starting frequency channel. Default is 200.
        stop: int
            Stopping/endign frequency channel. Default is 900.
        uvlength: float
            UV length in metres equal to or smaller to exclude while generating the image. Default is 0.        
        gridmode: string
            Gridding kernel for FFT-based transforms
    wprojplanes : int
        Number of w-projection planes for convolution; -1 => automatic determination
        del_script : boolean
            If True, deletes the casa script used to execute the CASA clean task.
            Default is True.
        """
        ct.imaging(self.ms, imagename, antenna=antenna, cellsize=cellsize, npix=npix, niter=niter, threshold=threshold, weighting=weighting, start=start, stop=stop, uvlength=uvlength, gridmode=gridmode, wprojplanes=wprojplanes, script=script, delete=del_script)
            
    def remove_image(self, imagename, del_img=False):
        """
        Removes unecesssary images spit by CASA
        Parameters
        ----------
        imagename : str
            Name of output casa image.
        del_img : boolean
            If True, removes the casa image file as well.
            Default is False.
        """
        os.system('rm -r {}.model'.format(imagename))
        os.system('rm -r {}.flux'.format(imagename))
        os.system('rm -r {}.psf'.format(imagename))
        os.system('rm -r {}.residual'.format(imagename))
        if del_img:
            os.system('rm -r {}.image'.format(imagename))

    def to_fits(self, imagename, fitsname=None, script='to_fits', del_script=True, overwrite=False):
        """
        Convert CASA image file to FITS format    
        Parameters
        ----------
        imagename : str
            Name of output casa image.
        fitsname : str
            Name of output fitsfile
        overwrite : boolean
            If True, overwrites the existing image with the new one.
            Default is False.
        """
        input_image = imagename + '.image'
        ct.exportfits(input_image, fitsname=fitsname, script=script, overwrite=overwrite)

    def plot_image(self, fitsfile, cmap='gray', vmin=None, vmax=None, title=''):
        """
        Read in and plot the fisfile into a 2D waterfall plot.
        Parameters
        ----------
        fitsfile : str
            Name of input fitsfile to read.
        cmap : str
            Color map of the 2D plot. Default is gray.
        vmin : float
            Minimum colorbar value for the plot. Default is
            minimum of the data.
        vmax : float
            Minimum colorbar value for the plot. Default is
            maximum of the data.
        """
        fitsinfo = ft.get_fitsinfo(fitsfile)
        data, header = fitsinfo['data'], fitsinfo['hdr']
        my_wcs = wcs.WCS(header, naxis=[wcs.WCSSUB_CELESTIAL])
        if vmin is None:
            vmin = np.min(data)
        if vmax is None:
            vmax = np.max(data)
        fig = pylab.figure(figsize=(6, 5))
        ax = fig.add_subplot(111, projection=my_wcs)
        im= ax.imshow(data, origin='lower', interpolation='nearest', cmap=cmap, vmin=vmin, vmax=vmax)
        cbar = pylab.colorbar(im, ax=ax)
        cbar.set_label(header['BUNIT'])
        ax.coords[0].set_axislabel('R.A. [deg]')
        ax.coords[1].set_axislabel('Dec [deg]')
        pylab.grid(lw=1, color='black')
        pylab.title(title, size=12)
        pylab.show()

    def subtract_model(self, outfile, del_script=True):
        """
        Subtracts CLEAN model from data
        outfile : str
              Name of the output residual file
        """
        os.system('cp -r {} {}'.format(self.ms, outfile))        
        ct.subtract_model(outfile, delete=del_script)
        
    def delete_log(self):
        """
        Delete unecessary files created during execution
        """
        os.system('rm -rf *.log')
        os.system('rm -rf *.log~')
        os.system('rm -rf *.last')
        os.system('rm -rf *.last~')
