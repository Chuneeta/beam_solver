import casa_utils as ct
import pyuvdata
from astropy.time import Time
import os

class UVConvert(object):
    def __init__(self, dset, outfile=None):
        """
        Object to store measurement sets of Miriad files containing visibilities in order to
        convert them to measurements.
    
        Parameters
        ----------
        dset : str 
            Miriad file containing visibilities are required metadata.
        """
        
        self.dset = dset
        if outfile is None: 
            self.outfile = '{}.ms'.format(outfile)
        else:
            self.outfile = outfile 

    def convert_mset(self, phs=None, del_uvfits=False, clobber=True):
        """
        Converts Miriad file to Measurement set (MS)
        
        Parameters
        ----------
        phs : float, optional
            Julian date at which to phase the visibilities. By default the visibilities are phased to first timestamp of the file

        del_uvfits : boolean, optional
            If True, deleted the uvfits file that is created during the conversion from uvfile to ms.
            Default is False.
        """

        uvd = pyuvdata.UVData()
        uvd.read_miriad(self.dset)
        times = uvd.time_array
        phs_time = times[0] if phs is None else phs

        print ('Phasing visibilities to {}'.format(phs_time))
        uvd.phase_to_time(Time(phs_time, format='jd', scale='utc'))

        # converting to uvfits
        uvfits = self.dset + '.uvfits'
        print ('Converting {} to {}'.format(self.dset, uvfits))
        uvd.write_uvfits(uvfits, spoof_nonessential=True)
        
        # converting to mset
        if clobber:
            if os.path.exists(self.outfile):
                os.system('rm -rf {}'.format(self.outfile))
        ct.uvfits2ms(uvfits, outfile=self.outfile, delete=True)
 
class Imaging(object):
    def __init__(self, ms):
        """
        Object to store measurement sets of meausrement files containing visibilities and performs
        operations such as imaging.

        Parameters
        ----------
        ms : str
            Measurement set file containing visibilities are required metadata.
        """

        self.ms = ms
	
    def generate_images(self, imagename, antenna='', cellsize='8arcmin', npix=512, niter=0, threshold='0Jy', weighting='uniform', start=200, stop=900, uvlength=0):
        """
        Generates multi-frequency synthesized images using all baselines within the specified cutoff threshold
    
        Parameters
        ---------
        imagename: string
            Name of output casa image

        antenna: string
            Antenna(s) or baseline(s) to used for imaging.
            e.g antenna='0' uses data from antenna 0 only
            antenna='0,4,5' uses data from antennas 0,4 and 5
            antenna='0&3' uses data from baseline 0-3
            antenna='0&3; 4&3' uses data from baselines 0-3 and 4-3
            Default is ''(all) which uses all the baselines

        cellsize: string
            Degrees to be contained in one pixel of the image.
            Default is 8 arcmins.

        npix: int
            Number of pixel the output image is along x(l) and y(m) axis.
            Default is 512.

        niter: integer
            Number of iterations to use for deconvolution. Default is 0.
            Hence, dirty images are generated by default.

        threshold: string
            Cleaning threshold in Jy or mJy. Default is 0 Jy.

        weighting: string
            Weighting to be using for gridding of uv points. Default is uniform.

        start: int
            Starting frequency channel. Default is 200.

        stop: int
            Stopping/endign frequency channel. Default is 900.

        uvlength: float
            Uv length in metres equal to or smaller to exclude while generating the image. Default is 0.
        """

        ct.imaging(self.ms, imagename, antenna=antenna, cellsize=cellsize, npix=npix, niter=niter, threshold=threshold, weighting=weighting, start=start, stop=stop, uvlength=uvlength, delete=False)
        #ct.exportfits(imagename)
        #ct.remove_image(imagename)       
       
